#!/usr/bin/env python3

import subprocess
import re
import os
import sys
from optparse import OptionParser
import time
import random

#need mat plot lib to draw a plot, I can install it on my machine, get the results file from the server, then draw the plot using that data while running a script on my machine
def test(options, iteration_1, testDrives):
    if iteration_1 == True:
        print(iteration_1)
        allDRIVES=subprocess.Popen(["cat", "/etc/vdev_id.conf"], stdout = subprocess.PIPE, universal_newlines = True).stdout
        for line in allDRIVES:
            regex = re.search("^alias\s+(\S+)\s", line)
            if regex != None  and regex.group(1) != None:
                #print(regex.group(1))
                driveName=regex.group(1).strip()
                drive = subprocess.run(["readlink", "/dev/"+driveName], stdout=subprocess.PIPE, universal_newlines=True).stdout
                #print(drive)
                if drive != '':
                    drive=drive.strip()
                    testDrives.append(drive)
        iteration_1=False
        
    print("drives for the test: {d}".format(d=testDrives))
    print(len(testDrives))
    random.shuffle(testDrives)
    if options.numdrives != 0 and options.maxdrives != 0:
        sys.exit("the -d and -m options cannot be used together")
    
    badDrives = []
    
    for drive in testDrives:
        filename="test"
        drive = checkDrivesToUse(options, testDrives, drive)
        for i in range(testDrives.index(drive)+1):
            if testDrives.index(drive) == 0 and drive not in badDrives:
                filename = ":/dev/"+drive
            elif drive not in badDrives:
                filename+=":/dev/"+testDrives[i]
                
        outputFile=testDrives.index(drive)+1
        outputFile=str(outputFile)
        print(filename)
        print(outputFile) 
        
        f=open(outputFile, "w+")
        results = subprocess.call(["fio", "--name=seqwrite", "--readwrite={optionsDotRW}".format(optionsDotRW=options.read_write), "--filename="+filename,\
        "--ioengine=libaio", "--filesize={f}".format(f=options.file_size), "--bs={optionsDotBS}".format(optionsDotBS=options.block_size), "--numjobs={optionsDotNJ}".format(optionsDotNJ=options.numjobs)\
        , "--output="+outputFile], stdout=subprocess.PIPE, 
        universal_newlines=True)
        #time.sleep(5)
        
        trackBadDrives(drive, badDrives, results)
        
        f=open(outputFile, "r+")
        performanceData=f.readlines()
        
        f2=open("BenchMKresults", "a+")

        for line in performanceData:
            read_performance = re.search("read:\s+IOPS=(\d+\.*\d+)(.*),\s+BW=(\d+\.*\d+)(\S+)\s+.*$", line)
            if read_performance != None:
                #deal with units
                IOPS, BW = checkUnits(read_performance)    
                f2.write("{n},{io},{bw}\n".format(n=outputFile, io=IOPS, bw=BW))
            write_performance = re.search("write:\s+IOPS=(\d+\.*\d+)(.*),\s+BW=(\d+\.*\d+)(\S+)\s+.*$", line)
            if write_performance != None:
                #deal with units
                IOPS, BW = checkUnits(read_performance) 
                f2.write("{n},{io},{bw}\n".format(n=outputFile, io=IOPS, bw=BW))
        f2.close()

        if checkToBreak(options, testDrives, drive) == True:
            break
        
        outputFile=int(outputFile)
        outputFile+=1
    return iteration_1
        
def checkToBreak(options, testDrives, drive):
    if options.maxdrives != 0:
        if testDrives.index(drive)+1 == options.maxdrives:
                return True
    if options.numdrives != 0:
        return True
    else:
        return False

def checkDrivesToUse(options, testDrives, drive):
    if options.numdrives != 0 and options.numdrives <= len(testDrives):
        return testDrives[options.numdrives-1]
    else:
        return drive
        
def trackBadDrives(drive, badDrives, results):
    if results != 0:
        badDrives.append(drive)

def checkUnits(regex):
    IOPS=regex.group(1)
    BW=regex.group(3)
    if regex.group(2) != None:
        print(regex.group(2))
        if regex.group(2) == "k":   
            IOPS=float(IOPS)
            IOPS*=1000
            str(IOPS)
    if regex.group(4) != None:
        print(regex.group(4))
        if regex.group(4) == "MiB/s":
            pass
        elif regex.group(4) == "KiB/s":
            BW=float(BW)
            BW/=1000
            str(BW)
        elif regex.group(4) == "GiB/s":
            BW=float(BW)
            BW*=1000
            str(BW)
    return IOPS, BW
    
def main():
    
    parser=OptionParser()
    
    parser.add_option("-b", "--block-size", action="store", type=str, default="256k", dest="block_size", help="[-s] set the block size for the test")
    parser.add_option("-f", "--file-size", action="store", type=str, default="1g", dest="file_size", help="[-s] set the file size for the test")
    parser.add_option("-r", "--read-write", action="store", type=str, default="read", dest="read_write", help="[-rw] set the read or write for the test. Valid choices are: \n \
    - read : sequential read \n - write : sequential write \n - randread: random read \n - randwrite: random write \n trim: Sequential trims (Linux block devices and SCSI character \
    devices only). \n randtrim: Random trims (Linux block devices and SCSI character devices only) \n rw,readwrite: Sequential mixed reads and writes \n randrw Random mixed reads \
    and writes \n trimwrite: Sequential trim+write sequences. Blocks will be trimmed first, then the same blocks will be written to \n default = read " )
    parser.add_option("-j", "--number-of-jobs", action="store", type=int, default=1, dest="numjobs", help="[-n] set the number of jobs that are occuring in parallel" )
    parser.add_option("-d", "--number-of-drives", action="store", type=int, default=0, dest="numdrives", help="[d]: set a specific number of drives to use for a single test. If\
    0 is entered, resorts to the default of testing all available drives, incrementing by one for consecutive tests. If the desired number is not available, the next lowest integer\
    number of drives are used")
    parser.add_option("-m", "--max-number-of-drives", action="store", type=int, default=0, dest="maxdrives", help="[m]: set the max number of drives. If 0 is entered resorts \
    to the default of all available drives")
    parser.add_option("-n", "--number-of-tests", action="store", type=int, default=1, dest="numtests", help="[n]: how many times to run the same set of tests")
    testName="Test"
    (options, values) = parser.parse_args()
    testName="bs "+options.block_size+" fs "+options.file_size+" rw "+options.read_write+" j "+str(options.numjobs)+" n "+str(options.numtests)
    if options.maxdrives != 0:
        testName+=" m "+str(options.maxdrives)
    if options.numdrives != 0:
        testName+=" d "+str(options.numdrives)
    testName+="\n"
    f2=open("BenchMKresults", "w+")
    ############## overwrite previous test results
    f2.write("DefaultName\n")
    f2.close()      
    ##############
    testDrives=[]
    iteration_1=True
    for i in range(options.numtests):
        iteration_1=test(options, iteration_1, testDrives)
        
       
if __name__ == "__main__":
    main()